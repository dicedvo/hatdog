import { supabase } from './supabase'
import { Task, TeamMember, Project, Organization, Column } from '@/types'

// Organizations API
export const organizationsAPI = {
  // Get organization by ID
  async getById(id: string): Promise<Organization> {
    const { data, error } = await supabase
      .from('organizations')
      .select('*')
      .eq('id', id)
      .single()
    
    if (error) throw error
    return data
  },

  // Get organization by invite code
  async getByInviteCode(inviteCode: string): Promise<Organization> {
    const { data, error } = await supabase
      .from('organizations')
      .select('*')
      .eq('invite_code', inviteCode)
      .single()
    
    if (error) throw error
    return data
  },

  // Create organization
  async create(name: string, userId: string): Promise<Organization> {
    const { data, error } = await supabase
      .from('organizations')
      .insert({
        name,
        created_by: userId,
        invite_code: '' // Will be auto-generated by trigger
      })
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Get user's organization
  async getUserOrganization(userId: string): Promise<Organization | null> {
    const { data, error } = await supabase
      .from('team_members')
      .select('organization_id')
      .eq('user_id', userId)
      .single()
    
    if (error) return null
    if (!data?.organization_id) return null

    return this.getById(data.organization_id)
  }
}

// Team Members API
export const teamAPI = {
  // Get all active team members for an organization
  async getAll(organizationId?: string): Promise<TeamMember[]> {
    let query = supabase
      .from('team_members')
      .select('*')
      .eq('is_active', true)
    
    // Filter by organization if provided
    if (organizationId) {
      query = query.eq('organization_id', organizationId)
    }
    
    const { data, error } = await query.order('name')
    
    if (error) throw error
    return data || []
  },

  // Create new team member
  async create(member: Omit<TeamMember, 'id' | 'created_at' | 'updated_at'>): Promise<TeamMember> {
    const { data, error } = await supabase
      .from('team_members')
      .insert(member)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Update team member
  async update(id: string, updates: Partial<TeamMember>): Promise<TeamMember> {
    const { data, error } = await supabase
      .from('team_members')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from('team_members')
      .delete()
      .eq('id', id)
    
    if (error) throw error
  }
}

// Tasks API
export const tasksAPI = {
  // Get all tasks with assignee info for an organization
  async getAll(organizationId?: string): Promise<Task[]> {
    let query = supabase.from('tasks').select('*')
    
    // Filter by organization if provided
    if (organizationId) {
      query = query.eq('organization_id', organizationId)
    }
    
    const { data: tasks, error: tasksError } = await query.order('position')
    
    if (tasksError) throw tasksError
    
    // Fetch team members for the same organization
    let membersQuery = supabase.from('team_members').select('*')
    if (organizationId) {
      membersQuery = membersQuery.eq('organization_id', organizationId)
    }
    const { data: members } = await membersQuery
    
    // Fetch multiple assignees for each task
    const assigneesByTask: Record<string, any[]> = {};
    if (tasks && tasks.length > 0) {
      const taskIds = tasks.map(t => t.id);
      const { data: assignees } = await supabase
        .from('task_assignees')
        .select(`
          task_id,
          team_member:team_members(*)
        `)
        .in('task_id', taskIds);
      
      // Group assignees by task_id
      assignees?.forEach(a => {
        if (!assigneesByTask[a.task_id]) {
          assigneesByTask[a.task_id] = [];
        }
        if (a.team_member) {
          assigneesByTask[a.task_id].push(a.team_member);
        }
      });
    }
    
    // Map assignees and creators to tasks
    const tasksWithAssignees = (tasks || []).map(task => ({
      ...task,
      assignee: task.assignee_id ? members?.find(m => m.id === task.assignee_id) : null,
      assignees: assigneesByTask[task.id] || [],
      creator: task.created_by ? members?.find(m => m.user_id === task.created_by) : null
    }))
    
    return tasksWithAssignees
  },

  // Create new task
  async create(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<Task> {
    const { data, error } = await supabase
      .from('tasks')
      .insert(task)
      .select('*')
      .single()
    
    if (error) throw error
    
    // Fetch assignee separately if needed
    if (data.assignee_id) {
      const { data: assignee } = await supabase
        .from('team_members')
        .select('*')
        .eq('id', data.assignee_id)
        .single()
      
      return { ...data, assignee }
    }
    
    return { ...data, assignee: null }
  },

  // Update task
  async update(id: string, updates: Partial<Task>): Promise<Task> {
    const { data, error } = await supabase
      .from('tasks')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select('*')
      .single()
    
    if (error) throw error
    
    // Fetch assignee separately if needed
    if (data.assignee_id) {
      const { data: assignee } = await supabase
        .from('team_members')
        .select('*')
        .eq('id', data.assignee_id)
        .single()
      
      return { ...data, assignee }
    }
    
    return { ...data, assignee: null }
  },

  // Delete task
  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from('tasks')
      .delete()
      .eq('id', id)
    
    if (error) throw error
  },

  // Update task position and column (for drag and drop)
  async updatePosition(id: string, columnIdOrStatus: string, position: number): Promise<Task> {
    const updateData: any = {
      position,
      updated_at: new Date().toISOString()
    };
    
    // Check if it's a UUID (column_id) or status string
    if (columnIdOrStatus.includes('-')) {
      updateData.column_id = columnIdOrStatus;
    } else {
      updateData.status = columnIdOrStatus;
    }
    
    const { data, error } = await supabase
      .from('tasks')
      .update(updateData)
      .eq('id', id)
      .select('*')
      .single()
    
    if (error) throw error
    
    // Fetch assignee separately if needed
    if (data.assignee_id) {
      const { data: assignee } = await supabase
        .from('team_members')
        .select('*')
        .eq('id', data.assignee_id)
        .single()
      
      return { ...data, assignee }
    }
    
    return { ...data, assignee: null }
  },

  // Add assignees to a task
  async addAssignees(taskId: string, memberIds: string[]): Promise<void> {
    const assignees = memberIds.map(memberId => ({
      task_id: taskId,
      team_member_id: memberId
    }));
    
    const { error } = await supabase
      .from('task_assignees')
      .insert(assignees)
      .select();
    
    if (error && !error.message.includes('duplicate')) throw error;
  },

  // Remove assignee from a task
  async removeAssignee(taskId: string, memberId: string): Promise<void> {
    const { error } = await supabase
      .from('task_assignees')
      .delete()
      .eq('task_id', taskId)
      .eq('team_member_id', memberId);
    
    if (error) throw error;
  },

  // Update all assignees for a task (replace existing)
  async updateAssignees(taskId: string, memberIds: string[]): Promise<void> {
    // Delete existing assignees
    const { error: deleteError } = await supabase
      .from('task_assignees')
      .delete()
      .eq('task_id', taskId);
    
    if (deleteError) throw deleteError;
    
    // Add new assignees
    if (memberIds.length > 0) {
      await this.addAssignees(taskId, memberIds);
    }
  }
}

// Columns API
export const columnsAPI = {
  // Get all columns for an organization
  async getAll(organizationId: string): Promise<Column[]> {
    const { data, error } = await supabase
      .from('columns')
      .select('*')
      .eq('organization_id', organizationId)
      .order('position')
    
    if (error) throw error
    return data || []
  },

  // Create new column
  async create(column: Omit<Column, 'id' | 'created_at' | 'updated_at'>): Promise<Column> {
    const { data, error } = await supabase
      .from('columns')
      .insert(column)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Update column
  async update(id: string, updates: Partial<Column>): Promise<Column> {
    const { data, error } = await supabase
      .from('columns')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    return data
  },

  // Delete column
  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from('columns')
      .delete()
      .eq('id', id)
    
    if (error) throw error
  },

  // Initialize default columns for new organization
  async initializeDefaults(organizationId: string): Promise<void> {
    const defaultColumns = [
      { organization_id: organizationId, title: 'To Do', position: 0, color: 'gray' },
      { organization_id: organizationId, title: 'In Progress', position: 1, color: 'blue' },
      { organization_id: organizationId, title: 'Review', position: 2, color: 'yellow' },
      { organization_id: organizationId, title: 'Done', position: 3, color: 'green' }
    ]
    
    const { error } = await supabase
      .from('columns')
      .insert(defaultColumns)
    
    if (error) throw error
  }
}

// Projects API (for later)
export const projectsAPI = {
  async getAll(): Promise<Project[]> {
    const { data, error } = await supabase
      .from('projects')
      .select('*')
      .order('name')
    
    if (error) throw error
    return data || []
  }
}